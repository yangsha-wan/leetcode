https://www.e-learn.cn/content/qita/1224371

一、排序

时间复杂度：O(n*lg(n))
明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？

二、局部排序
冒泡
时间复杂度：O(n*k)

三、堆
只找到Top-K，不排序Top-K。
时间复杂度：O(n*lg(k))

四、随机选择。快速排序的简化版本
所有分治的节点都只会执行一半
O(n)

五、bitmap算法
空间换时间。适用于所有的数可以hash。如所有的数都是32位int，2^32个bit可以表示
O(n)